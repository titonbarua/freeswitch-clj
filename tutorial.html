<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Tutorial</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Freeswitch-clj</span> <span class="project-version">0.2.2-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="tutorial.html"><div class="inner"><span>Tutorial</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="freeswitch-clj.core.html"><div class="inner"><span>freeswitch-clj.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#tutorial" name="tutorial"></a>Tutorial</h1>
<p><code>freeswitch-clj</code> is an event socket interface for FreeSWITCH in Clojure. This is an open source project released under MIT Pulic License. Read the the project README file hosted in <a href="http://https://github.com/titonbarua/freeswitch-clj">github</a> for notes on installation and basic usage examples.</p>
<p>This document demonstrates the usage of the library with some additional examples.</p>
<h2><a href="#inbound-mode" name="inbound-mode"></a>Inbound mode</h2>
<p>Here’s a basic setup to send some commands to freeswitch in inbound mode:</p>
<pre><code class="clojure">(require '[freeswitch-clj.core :as f])

;; Make a connection.
(def conn (f/connect :host "127.0.0.1"))

;; Print result of an api request.
(println (f/req-api conn "status"))

(f/disconnect conn)
</code></pre>
<h3><a href="#originating-a-call" name="originating-a-call"></a>Originating a call</h3>
<pre><code class="clojure">(require '[freeswitch-clj.core :as f])

;; Make a connection.
(def conn (f/connect :host "127.0.0.1"))

;; Originate an outgoing call. Serves a TTS greeting upon answer.
(f/req-api "originate {origination_caller_id_number=+15551234567}sofia/gateway/mygw/+5557654321 '&amp;speak(flite|kal|Hello world!)' XML default")

(f/disconnect conn)
</code></pre>
<h3><a href="#handling-result-of-background-jobs" name="handling-result-of-background-jobs"></a>Handling result of background jobs</h3>
<p>The function <code>req-bgapi</code> can be used to effortlessly handle result of background jobs.</p>
<pre><code class="clojure">;; Define a result handler function.
(defn bgjob-handler
    [conn rslt]
    (println "bgjob result:" rslt))

;; Make a bgapi request.
(f/req-bgapi conn bgjob-handler "status")
</code></pre>
<h3><a href="#handling-events-the-high-level-way" name="handling-events-the-high-level-way"></a>Handling events, the high-level way</h3>
<p>Function <code>req-event</code> can be used to both subscribe and setup handler for an event.</p>
<pre><code class="clojure">;; Define an event handler.
(defn event-handler
    [conn event-map]
    (println "Received event:" event-map))

;; Watch for a heartbeat event.
(f/req-event conn
             event-handler
             :event-name "HEARTBEAT")
</code></pre>
<h3><a href="#handling-events-the-low-level-approach" name="handling-events-the-low-level-approach"></a>Handling events, the low-level approach</h3>
<p>For more control, event handler binding and event subscription can be separated.</p>
<pre><code class="clojure">;; Bind event handler.
(f/bind-event
    conn
    (fn [conn event-map]
        (println "Received heartbeat:" event-map))
    :event-name "HEARTBEAT")

;; Subscribe to the event.
(f/req-cmd conn "event HEARTBEAT")
</code></pre>
<h2><a href="#outbound-mode" name="outbound-mode"></a>Outbound mode</h2>
<p>A basic outbound setup where freeswitch is configured to knock on port <code>10000</code> for decision about call routing:</p>
<pre><code class="clojure">(require '[freeswitch-clj.core :as f])

;; Create a connection handler.


As well as source files, Codox also tries to include documentation files as well. By default it looks for these in the doc directory, but you can change this with:(defn conn-handler
    [conn chan-data]
    (println "Channel data:" chan-data)
    (println (f/req-api conn "status"))

    ;; Send 'exit' command.
    (f/disconnect conn)
    ;; Wait for connection to close.
    @(conn :closed?))


;; Listen for outbound connections from freeswitch on port 10000.
(f/listen :port 10000
          :handler conn-handler)
</code></pre>
<p>It is possible to make api calls and setup &amp; listen for events from inside the connection handler function, just like inbound mode. Note that the connection handler function is blocking, but runs in a separate <code>core.async</code> thread. Exiting this function means we are done with the connection. This implies, in case of doing a full-on call scripting with lot’s of event processing, you can wait for a promise to be delivered which is can be found under <code>:closed?</code> key in connection map.</p></div></div></div></body></html>